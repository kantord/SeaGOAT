"""
This type stub file was generated by pyright.
"""

import datetime
import git.diff as git_diff
from git.objects import Blob, Commit, Submodule, Tree
from git.objects.util import Serializable
from git.util import Actor, LazyMixin
from .fun import S_IFGITLINK
from .typ import BaseIndexEntry, StageType
from .util import default_index, post_clear_cache
from typing import (
    Any,
    Callable,
    Dict,
    Iterable,
    Iterator,
    List,
    Sequence,
    TYPE_CHECKING,
    Tuple,
    Type,
    Union,
)
from git.types import Commit_ish, PathLike
from git.repo import Repo
from git.refs.reference import Reference

if TYPE_CHECKING: ...
Treeish = Union[Tree, Commit, str, bytes]
__all__ = ("IndexFile", "CheckoutError", "StageType")

class IndexFile(LazyMixin, git_diff.Diffable, Serializable):
    """
    Implements an Index that can be manipulated using a native implementation in
    order to save git command function calls wherever possible.

    It provides custom merging facilities allowing to merge without actually changing
    your index or your working tree. This way you can perform own test-merges based
    on the index only without having to deal with the working copy. This is useful
    in case of partial working trees.

    ``Entries``

    The index contains an entries dict whose keys are tuples of type IndexEntry
    to facilitate access.

    You may read the entries dict or manipulate it using IndexEntry instance, i.e.::

        index.entries[index.entry_key(index_entry_instance)] = index_entry_instance

    Make sure you use index.write() once you are done manipulating the index directly
    before operating on it using the git command"""

    __slots__ = ...
    _VERSION = ...
    S_IFGITLINK = ...
    def __init__(self, repo: Repo, file_path: Union[PathLike, None] = ...) -> None:
        """Initialize this Index instance, optionally from the given ``file_path``.
        If no file_path is given, we will be created from the current index file.

        If a stream is not given, the stream will be initialized from the current
        repository's index on demand."""
        ...
    @property
    def path(self) -> PathLike:
        """:return: Path to the index file we are representing"""
        ...
    def write(
        self, file_path: Union[None, PathLike] = ..., ignore_extension_data: bool = ...
    ) -> None:
        """Write the current state to our file path or to the given one

        :param file_path:
            If None, we will write to our stored file path from which we have
            been initialized. Otherwise we write to the given file path.
            Please note that this will change the file_path of this index to
            the one you gave.

        :param ignore_extension_data:
            If True, the TREE type extension data read in the index will not
            be written to disk. NOTE that no extension data is actually written.
            Use this if you have altered the index and
            would like to use git-write-tree afterwards to create a tree
            representing your written changes.
            If this data is present in the written index, git-write-tree
            will instead write the stored/cached tree.
            Alternatively, use IndexFile.write_tree() to handle this case
            automatically

        :return: self  # does it? or returns None?"""
        ...
    @post_clear_cache
    @default_index
    def merge_tree(self, rhs: Treeish, base: Union[None, Treeish] = ...) -> IndexFile:
        """Merge the given rhs treeish into the current index, possibly taking
        a common base treeish into account.

        As opposed to the :func:`IndexFile.from_tree` method, this allows you to use an already
        existing tree as the left side of the merge

        :param rhs:
            treeish reference pointing to the 'other' side of the merge.

        :param base:
            optional treeish reference pointing to the common base of 'rhs' and
            this index which equals lhs

        :return:
            self ( containing the merge and possibly unmerged entries in case of
            conflicts )

        :raise GitCommandError:
            If there is a merge conflict. The error will
            be raised at the first conflicting path. If you want to have proper
            merge resolution to be done by yourself, you have to commit the changed
            index ( or make a valid tree from it ) and retry with a three-way
            index.from_tree call."""
        ...
    @classmethod
    def new(cls, repo: Repo, *tree_sha: Union[str, Tree]) -> IndexFile:
        """Merge the given treeish revisions into a new index which is returned.
        This method behaves like git-read-tree --aggressive when doing the merge.

        :param repo: The repository treeish are located in.

        :param tree_sha:
            20 byte or 40 byte tree sha or tree objects

        :return:
            New IndexFile instance. Its path will be undefined.
            If you intend to write such a merged Index, supply an alternate file_path
            to its 'write' method."""
        ...
    @classmethod
    def from_tree(cls, repo: Repo, *treeish: Treeish, **kwargs: Any) -> IndexFile:
        """Merge the given treeish revisions into a new index which is returned.
        The original index will remain unaltered

        :param repo:
            The repository treeish are located in.

        :param treeish:
            One, two or three Tree Objects, Commits or 40 byte hexshas. The result
            changes according to the amount of trees.
            If 1 Tree is given, it will just be read into a new index
            If 2 Trees are given, they will be merged into a new index using a
            two way merge algorithm. Tree 1 is the 'current' tree, tree 2 is the 'other'
            one. It behaves like a fast-forward.
            If 3 Trees are given, a 3-way merge will be performed with the first tree
            being the common ancestor of tree 2 and tree 3. Tree 2 is the 'current' tree,
            tree 3 is the 'other' one

        :param kwargs:
            Additional arguments passed to git-read-tree

        :return:
            New IndexFile instance. It will point to a temporary index location which
            does not exist anymore. If you intend to write such a merged Index, supply
            an alternate file_path to its 'write' method.

        :note:
            In the three-way merge case, --aggressive will be specified to automatically
            resolve more cases in a commonly correct manner. Specify trivial=True as kwarg
            to override that.

            As the underlying git-read-tree command takes into account the current index,
            it will be temporarily moved out of the way to assure there are no unsuspected
            interferences."""
        ...
    def iter_blobs(
        self, predicate: Callable[[Tuple[StageType, Blob]], bool] = ...
    ) -> Iterator[Tuple[StageType, Blob]]:
        """
        :return: Iterator yielding tuples of Blob objects and stages, tuple(stage, Blob)

        :param predicate:
            Function(t) returning True if tuple(stage, Blob) should be yielded by the
            iterator. A default filter, the BlobFilter, allows you to yield blobs
            only if they match a given list of paths."""
        ...
    def unmerged_blobs(self) -> Dict[PathLike, List[Tuple[StageType, Blob]]]:
        """
        :return:
            Dict(path : list( tuple( stage, Blob, ...))), being
            a dictionary associating a path in the index with a list containing
            sorted stage/blob pairs


        :note:
            Blobs that have been removed in one side simply do not exist in the
            given stage. I.e. a file removed on the 'other' branch whose entries
            are at stage 3 will not have a stage 3 entry.
        """
        ...
    @classmethod
    def entry_key(
        cls, *entry: Union[BaseIndexEntry, PathLike, StageType]
    ) -> Tuple[PathLike, StageType]: ...
    def resolve_blobs(self, iter_blobs: Iterator[Blob]) -> IndexFile:
        """Resolve the blobs given in blob iterator. This will effectively remove the
        index entries of the respective path at all non-null stages and add the given
        blob as new stage null blob.

        For each path there may only be one blob, otherwise a ValueError will be raised
        claiming the path is already at stage 0.

        :raise ValueError: if one of the blobs already existed at stage 0
        :return: self

        :note:
            You will have to write the index manually once you are done, i.e.
            index.resolve_blobs(blobs).write()
        """
        ...
    def update(self) -> IndexFile:
        """Reread the contents of our index file, discarding all cached information
        we might have.

        :note: This is a possibly dangerious operations as it will discard your changes
            to index.entries
        :return: self"""
        ...
    def write_tree(self) -> Tree:
        """Writes this index to a corresponding Tree object into the repository's
        object database and return it.

        :return: Tree object representing this index
        :note: The tree will be written even if one or more objects the tree refers to
            does not yet exist in the object database. This could happen if you added
            Entries to the index directly.
        :raise ValueError: if there are no entries in the cache
        :raise UnmergedEntriesError:"""
        ...
    def add(
        self,
        items: Sequence[Union[PathLike, Blob, BaseIndexEntry, Submodule]],
        force: bool = ...,
        fprogress: Callable = ...,
        path_rewriter: Union[Callable[..., PathLike], None] = ...,
        write: bool = ...,
        write_extension_data: bool = ...,
    ) -> List[BaseIndexEntry]:
        """Add files from the working tree, specific blobs or BaseIndexEntries
        to the index.

        :param items:
            Multiple types of items are supported, types can be mixed within one call.
            Different types imply a different handling. File paths may generally be
            relative or absolute.

            - path string
                strings denote a relative or absolute path into the repository pointing to
                an existing file, i.e. CHANGES, lib/myfile.ext, '/home/gitrepo/lib/myfile.ext'.

                Absolute paths must start with working tree directory of this index's repository
                to be considered valid. For example, if it was initialized with a non-normalized path, like
                `/root/repo/../repo`, absolute paths to be added must start with `/root/repo/../repo`.

                Paths provided like this must exist. When added, they will be written
                into the object database.

                PathStrings may contain globs, such as 'lib/__init__*' or can be directories
                like 'lib', the latter ones will add all the files within the directory and
                subdirectories.

                This equals a straight git-add.

                They are added at stage 0

            - Blob or Submodule object
                Blobs are added as they are assuming a valid mode is set.
                The file they refer to may or may not exist in the file system, but
                must be a path relative to our repository.

                If their sha is null ( 40*0 ), their path must exist in the file system
                relative to the git repository as an object will be created from
                the data at the path.
                The handling now very much equals the way string paths are processed, except that
                the mode you have set will be kept. This allows you to create symlinks
                by settings the mode respectively and writing the target of the symlink
                directly into the file. This equals a default Linux-Symlink which
                is not dereferenced automatically, except that it can be created on
                filesystems not supporting it as well.

                Please note that globs or directories are not allowed in Blob objects.

                They are added at stage 0

            - BaseIndexEntry or type
                Handling equals the one of Blob objects, but the stage may be
                explicitly set. Please note that Index Entries require binary sha's.

        :param force:
            **CURRENTLY INEFFECTIVE**
            If True, otherwise ignored or excluded files will be
            added anyway.
            As opposed to the git-add command, we enable this flag by default
            as the API user usually wants the item to be added even though
            they might be excluded.

        :param fprogress:
            Function with signature f(path, done=False, item=item) called for each
            path to be added, one time once it is about to be added where done==False
            and once after it was added where done=True.
            item is set to the actual item we handle, either a Path or a BaseIndexEntry
            Please note that the processed path is not guaranteed to be present
            in the index already as the index is currently being processed.

        :param path_rewriter:
            Function with signature (string) func(BaseIndexEntry) function returning a path
            for each passed entry which is the path to be actually recorded for the
            object created from entry.path. This allows you to write an index which
            is not identical to the layout of the actual files on your hard-disk.
            If not None and ``items`` contain plain paths, these paths will be
            converted to Entries beforehand and passed to the path_rewriter.
            Please note that entry.path is relative to the git repository.

        :param write:
            If True, the index will be written once it was altered. Otherwise
            the changes only exist in memory and are not available to git commands.

        :param write_extension_data:
            If True, extension data will be written back to the index. This can lead to issues in case
            it is containing the 'TREE' extension, which will cause the `git commit` command to write an
            old tree, instead of a new one representing the now changed index.
            This doesn't matter if you use `IndexFile.commit()`, which ignores the `TREE` extension altogether.
            You should set it to True if you intend to use `IndexFile.commit()` exclusively while maintaining
            support for third-party extensions. Besides that, you can usually safely ignore the built-in
            extensions when using GitPython on repositories that are not handled manually at all.
            All current built-in extensions are listed here:
            http://opensource.apple.com/source/Git/Git-26/src/git-htmldocs/technical/index-format.txt

        :return:
            List(BaseIndexEntries) representing the entries just actually added.

        :raise OSError:
            if a supplied Path did not exist. Please note that BaseIndexEntry
            Objects that do not have a null sha will be added even if their paths
            do not exist.
        """
        ...
    @post_clear_cache
    @default_index
    def remove(
        self,
        items: Sequence[Union[PathLike, Blob, BaseIndexEntry, Submodule]],
        working_tree: bool = ...,
        **kwargs: Any
    ) -> List[str]:
        """Remove the given items from the index and optionally from
        the working tree as well.

        :param items:
            Multiple types of items are supported which may be be freely mixed.

            - path string
                Remove the given path at all stages. If it is a directory, you must
                specify the r=True keyword argument to remove all file entries
                below it. If absolute paths are given, they will be converted
                to a path relative to the git repository directory containing
                the working tree

                The path string may include globs, such as \\*.c.

            - Blob Object
                Only the path portion is used in this case.

            - BaseIndexEntry or compatible type
                The only relevant information here Yis the path. The stage is ignored.

        :param working_tree:
            If True, the entry will also be removed from the working tree, physically
            removing the respective file. This may fail if there are uncommitted changes
            in it.

        :param kwargs:
            Additional keyword arguments to be passed to git-rm, such
            as 'r' to allow recursive removal of

        :return:
            List(path_string, ...) list of repository relative paths that have
            been removed effectively.
            This is interesting to know in case you have provided a directory or
            globs. Paths are relative to the repository."""
        ...
    @post_clear_cache
    @default_index
    def move(
        self,
        items: Sequence[Union[PathLike, Blob, BaseIndexEntry, Submodule]],
        skip_errors: bool = ...,
        **kwargs: Any
    ) -> List[Tuple[str, str]]:
        """Rename/move the items, whereas the last item is considered the destination of
        the move operation. If the destination is a file, the first item ( of two )
        must be a file as well. If the destination is a directory, it may be preceded
        by one or more directories or files.

        The working tree will be affected in non-bare repositories.

        :parma items:
            Multiple types of items are supported, please see the 'remove' method
            for reference.
        :param skip_errors:
            If True, errors such as ones resulting from missing source files will
            be skipped.
        :param kwargs:
            Additional arguments you would like to pass to git-mv, such as dry_run
            or force.

        :return: List(tuple(source_path_string, destination_path_string), ...)
            A list of pairs, containing the source file moved as well as its
            actual destination. Relative to the repository root.

        :raise ValueError: If only one item was given
        :raise GitCommandError: If git could not handle your request"""
        ...
    def commit(
        self,
        message: str,
        parent_commits: Union[Commit_ish, None] = ...,
        head: bool = ...,
        author: Union[None, Actor] = ...,
        committer: Union[None, Actor] = ...,
        author_date: Union[datetime.datetime, str, None] = ...,
        commit_date: Union[datetime.datetime, str, None] = ...,
        skip_hooks: bool = ...,
    ) -> Commit:
        """Commit the current default index file, creating a commit object.
        For more information on the arguments, see Commit.create_from_tree().

        :note: If you have manually altered the .entries member of this instance,
               don't forget to write() your changes to disk beforehand.
               Passing skip_hooks=True is the equivalent of using `-n`
               or `--no-verify` on the command line.
        :return: Commit object representing the new commit"""
        ...
    @default_index
    def checkout(
        self,
        paths: Union[None, Iterable[PathLike]] = ...,
        force: bool = ...,
        fprogress: Callable = ...,
        **kwargs: Any
    ) -> Union[None, Iterator[PathLike], Sequence[PathLike]]:
        """Checkout the given paths or all files from the version known to the index into
        the working tree.

        :note: Be sure you have written pending changes using the ``write`` method
            in case you have altered the enties dictionary directly

        :param paths:
            If None, all paths in the index will be checked out. Otherwise an iterable
            of relative or absolute paths or a single path pointing to files or directories
            in the index is expected.

        :param force:
            If True, existing files will be overwritten even if they contain local modifications.
            If False, these will trigger a CheckoutError.

        :param fprogress:
            see :func:`IndexFile.add` for signature and explanation.
            The provided progress information will contain None as path and item if no
            explicit paths are given. Otherwise progress information will be send
            prior and after a file has been checked out

        :param kwargs:
            Additional arguments to be passed to git-checkout-index

        :return:
            iterable yielding paths to files which have been checked out and are
            guaranteed to match the version stored in the index

        :raise exc.CheckoutError:
            If at least one file failed to be checked out. This is a summary,
            hence it will checkout as many files as it can anyway.
            If one of files or directories do not exist in the index
            ( as opposed to the  original git command who ignores them ).
            Raise GitCommandError if error lines could not be parsed - this truly is
            an exceptional state

        .. note:: The checkout is limited to checking out the files in the
            index. Files which are not in the index anymore and exist in
            the working tree will not be deleted. This behaviour is fundamentally
            different to *head.checkout*, i.e. if you want git-checkout like behaviour,
            use head.checkout instead of index.checkout.
        """
        ...
    @default_index
    def reset(
        self,
        commit: Union[Commit, Reference, str] = ...,
        working_tree: bool = ...,
        paths: Union[None, Iterable[PathLike]] = ...,
        head: bool = ...,
        **kwargs: Any
    ) -> IndexFile:
        """Reset the index to reflect the tree at the given commit. This will not
        adjust our HEAD reference as opposed to HEAD.reset by default.

        :param commit:
            Revision, Reference or Commit specifying the commit we should represent.
            If you want to specify a tree only, use IndexFile.from_tree and overwrite
            the default index.

        :param working_tree:
            If True, the files in the working tree will reflect the changed index.
            If False, the working tree will not be touched
            Please note that changes to the working copy will be discarded without
            warning !

        :param head:
            If True, the head will be set to the given commit. This is False by default,
            but if True, this method behaves like HEAD.reset.

        :param paths: if given as an iterable of absolute or repository-relative paths,
            only these will be reset to their state at the given commit'ish.
            The paths need to exist at the commit, otherwise an exception will be
            raised.

        :param kwargs:
            Additional keyword arguments passed to git-reset

        .. note:: IndexFile.reset, as opposed to HEAD.reset, will not delete anyfiles
            in order to maintain a consistent working tree. Instead, it will just
            checkout the files according to their state in the index.
            If you want git-reset like behaviour, use *HEAD.reset* instead.

        :return: self"""
        ...
    def diff(
        self,
        other: Union[Type[git_diff.Diffable.Index], Tree, Commit, str, None] = ...,
        paths: Union[PathLike, List[PathLike], Tuple[PathLike, ...], None] = ...,
        create_patch: bool = ...,
        **kwargs: Any
    ) -> git_diff.DiffIndex:
        """Diff this index against the working copy or a Tree or Commit object

        For a documentation of the parameters and return values, see,
        Diffable.diff

        :note:
            Will only work with indices that represent the default git index as
            they have not been initialized with a stream.
        """
        ...
