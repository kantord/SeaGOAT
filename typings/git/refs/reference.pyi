"""
This type stub file was generated by pyright.
"""

from git.util import IterableObj, LazyMixin
from .symbolic import SymbolicReference, T_References
from typing import Any, Callable, Iterator, TYPE_CHECKING, Type, Union
from git.types import Commit_ish, PathLike, _T
from git.repo import Repo

if TYPE_CHECKING: ...
__all__ = ["Reference"]

def require_remote_ref_path(func: Callable[..., _T]) -> Callable[..., _T]:
    """A decorator raising a TypeError if we are not a valid remote, based on the path"""
    ...

class Reference(SymbolicReference, LazyMixin, IterableObj):
    """Represents a named reference to any object. Subclasses may apply restrictions though,
    i.e. Heads can only point to commits."""

    __slots__ = ...
    _points_to_commits_only = ...
    _resolve_ref_on_create = ...
    _common_path_default = ...
    def __init__(self, repo: Repo, path: PathLike, check_path: bool = ...) -> None:
        """Initialize this instance

        :param repo: Our parent repository
        :param path:
            Path relative to the .git/ directory pointing to the ref in question, i.e.
            refs/heads/master
        :param check_path: if False, you can provide any path. Otherwise the path must start with the
            default path prefix of this type."""
        ...
    def __str__(self) -> str: ...
    def set_object(
        self,
        object: Union[Commit_ish, SymbolicReference, str],
        logmsg: Union[str, None] = ...,
    ) -> Reference:
        """Special version which checks if the head-log needs an update as well

        :return: self"""
        ...
    @property
    def name(self) -> str:
        """:return: (shortest) Name of this reference - it may contain path components"""
        ...
    @classmethod
    def iter_items(
        cls: Type[T_References],
        repo: Repo,
        common_path: Union[PathLike, None] = ...,
        *args: Any,
        **kwargs: Any
    ) -> Iterator[T_References]:
        """Equivalent to SymbolicReference.iter_items, but will return non-detached
        references as well."""
        ...
    @property
    @require_remote_ref_path
    def remote_name(self) -> str:
        """
        :return:
            Name of the remote we are a reference of, such as 'origin' for a reference
            named 'origin/master'"""
        ...
    @property
    @require_remote_ref_path
    def remote_head(self) -> str:
        """:return: Name of the remote head itself, i.e. master.
        :note: The returned name is usually not qualified enough to uniquely identify
            a branch"""
        ...
