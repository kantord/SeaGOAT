"""
This type stub file was generated by pyright.
"""

from mmap import mmap
from git.objects.util import Serializable
from git.util import Actor
from typing import Iterator, List, TYPE_CHECKING, Tuple, Union
from git.types import PathLike
from git.refs import SymbolicReference
from io import BytesIO
from git.config import GitConfigParser, SectionConstraint

if TYPE_CHECKING: ...
__all__ = ["RefLog", "RefLogEntry"]

class RefLogEntry(Tuple[str, str, Actor, Tuple[int, int], str]):
    """Named tuple allowing easy access to the revlog data fields"""

    _re_hexsha_only = ...
    __slots__ = ...
    def __repr__(self) -> str:
        """Representation of ourselves in git reflog format"""
        ...
    def format(self) -> str:
        """:return: a string suitable to be placed in a reflog file"""
        ...
    @property
    def oldhexsha(self) -> str:
        """The hexsha to the commit the ref pointed to before the change"""
        ...
    @property
    def newhexsha(self) -> str:
        """The hexsha to the commit the ref now points to, after the change"""
        ...
    @property
    def actor(self) -> Actor:
        """Actor instance, providing access"""
        ...
    @property
    def time(self) -> Tuple[int, int]:
        """time as tuple:

        * [0] = int(time)
        * [1] = int(timezone_offset) in time.altzone format"""
        ...
    @property
    def message(self) -> str:
        """Message describing the operation that acted on the reference"""
        ...
    @classmethod
    def new(
        cls,
        oldhexsha: str,
        newhexsha: str,
        actor: Actor,
        time: int,
        tz_offset: int,
        message: str,
    ) -> RefLogEntry:
        """:return: New instance of a RefLogEntry"""
        ...
    @classmethod
    def from_line(cls, line: bytes) -> RefLogEntry:
        """:return: New RefLogEntry instance from the given revlog line.
        :param line: line bytes without trailing newline
        :raise ValueError: If line could not be parsed"""
        ...

class RefLog(List[RefLogEntry], Serializable):
    """A reflog contains RefLogEntrys, each of which defines a certain state
    of the head in question. Custom query methods allow to retrieve log entries
    by date or by other criteria.

    Reflog entries are ordered, the first added entry is first in the list, the last
    entry, i.e. the last change of the head or reference, is last in the list."""

    __slots__ = ...
    def __new__(cls, filepath: Union[PathLike, None] = ...) -> RefLog: ...
    def __init__(self, filepath: Union[PathLike, None] = ...) -> None:
        """Initialize this instance with an optional filepath, from which we will
        initialize our data. The path is also used to write changes back using
        the write() method"""
        ...
    @classmethod
    def from_file(cls, filepath: PathLike) -> RefLog:
        """
        :return: a new RefLog instance containing all entries from the reflog
            at the given filepath
        :param filepath: path to reflog
        :raise ValueError: If the file could not be read or was corrupted in some way"""
        ...
    @classmethod
    def path(cls, ref: SymbolicReference) -> str:
        """
        :return: string to absolute path at which the reflog of the given ref
            instance would be found. The path is not guaranteed to point to a valid
            file though.
        :param ref: SymbolicReference instance"""
        ...
    @classmethod
    def iter_entries(cls, stream: Union[str, BytesIO, mmap]) -> Iterator[RefLogEntry]:
        """
        :return: Iterator yielding RefLogEntry instances, one for each line read
            sfrom the given stream.
        :param stream: file-like object containing the revlog in its native format
            or string instance pointing to a file to read"""
        ...
    @classmethod
    def entry_at(cls, filepath: PathLike, index: int) -> RefLogEntry:
        """
        :return: RefLogEntry at the given index

        :param filepath: full path to the index file from which to read the entry

        :param index: python list compatible index, i.e. it may be negative to
            specify an entry counted from the end of the list

        :raise IndexError: If the entry didn't exist

        .. note:: This method is faster as it only parses the entry at index, skipping
            all other lines. Nonetheless, the whole file has to be read if
            the index is negative
        """
        ...
    def to_file(self, filepath: PathLike) -> None:
        """Write the contents of the reflog instance to a file at the given filepath.

        :param filepath: path to file, parent directories are assumed to exist"""
        ...
    @classmethod
    def append_entry(
        cls,
        config_reader: Union[Actor, GitConfigParser, SectionConstraint, None],
        filepath: PathLike,
        oldbinsha: bytes,
        newbinsha: bytes,
        message: str,
        write: bool = ...,
    ) -> RefLogEntry:
        """Append a new log entry to the revlog at filepath.

        :param config_reader: configuration reader of the repository - used to obtain
            user information. May also be an Actor instance identifying the committer directly or None.
        :param filepath: full path to the log file
        :param oldbinsha: binary sha of the previous commit
        :param newbinsha: binary sha of the current commit
        :param message: message describing the change to the reference
        :param write: If True, the changes will be written right away. Otherwise
            the change will not be written

        :return: RefLogEntry objects which was appended to the log

        :note: As we are append-only, concurrent access is not a problem as we
            do not interfere with readers."""
        ...
    def write(self) -> RefLog:
        """Write this instance's data to the file we are originating from

        :return: self"""
        ...
