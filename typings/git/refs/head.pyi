"""
This type stub file was generated by pyright.
"""

from git.config import GitConfigParser, SectionConstraint
from .symbolic import SymbolicReference
from .reference import Reference
from typing import Any, Sequence, TYPE_CHECKING, Union
from git.types import Commit_ish, PathLike
from git.repo import Repo
from git.refs import RemoteReference

if TYPE_CHECKING: ...
__all__ = ["HEAD", "Head"]

def strip_quotes(string: str) -> str: ...

class HEAD(SymbolicReference):
    """Special case of a Symbolic Reference as it represents the repository's
    HEAD reference."""

    _HEAD_NAME = ...
    _ORIG_HEAD_NAME = ...
    __slots__ = ...
    def __init__(self, repo: Repo, path: PathLike = ...) -> None: ...
    def orig_head(self) -> SymbolicReference:
        """
        :return: SymbolicReference pointing at the ORIG_HEAD, which is maintained
            to contain the previous value of HEAD"""
        ...
    def reset(
        self,
        commit: Union[Commit_ish, SymbolicReference, str] = ...,
        index: bool = ...,
        working_tree: bool = ...,
        paths: Union[PathLike, Sequence[PathLike], None] = ...,
        **kwargs: Any
    ) -> HEAD:
        """Reset our HEAD to the given commit optionally synchronizing
        the index and working tree. The reference we refer to will be set to
        commit as well.

        :param commit:
            Commit object, Reference Object or string identifying a revision we
            should reset HEAD to.

        :param index:
            If True, the index will be set to match the given commit. Otherwise
            it will not be touched.

        :param working_tree:
            If True, the working tree will be forcefully adjusted to match the given
            commit, possibly overwriting uncommitted changes without warning.
            If working_tree is True, index must be true as well

        :param paths:
            Single path or list of paths relative to the git root directory
            that are to be reset. This allows to partially reset individual files.

        :param kwargs:
            Additional arguments passed to git-reset.

        :return: self"""
        ...

class Head(Reference):
    """A Head is a named reference to a Commit. Every Head instance contains a name
    and a Commit object.

    Examples::

        >>> repo = Repo("/path/to/repo")
        >>> head = repo.heads[0]

        >>> head.name
        'master'

        >>> head.commit
        <git.Commit "1c09f116cbc2cb4100fb6935bb162daa4723f455">

        >>> head.commit.hexsha
        '1c09f116cbc2cb4100fb6935bb162daa4723f455'"""

    _common_path_default = ...
    k_config_remote = ...
    k_config_remote_ref = ...
    @classmethod
    def delete(
        cls, repo: Repo, *heads: Union[Head, str], force: bool = ..., **kwargs: Any
    ) -> None:
        """Delete the given heads

        :param force:
            If True, the heads will be deleted even if they are not yet merged into
            the main development stream.
            Default False"""
        ...
    def set_tracking_branch(
        self, remote_reference: Union[RemoteReference, None]
    ) -> Head:
        """
        Configure this branch to track the given remote reference. This will alter
            this branch's configuration accordingly.

        :param remote_reference: The remote reference to track or None to untrack
            any references
        :return: self"""
        ...
    def tracking_branch(self) -> Union[RemoteReference, None]:
        """
        :return: The remote_reference we are tracking, or None if we are
            not a tracking branch"""
        ...
    def rename(self, new_path: PathLike, force: bool = ...) -> Head:
        """Rename self to a new path

        :param new_path:
            Either a simple name or a path, i.e. new_name or features/new_name.
            The prefix refs/heads is implied

        :param force:
            If True, the rename will succeed even if a head with the target name
            already exists.

        :return: self
        :note: respects the ref log as git commands are used"""
        ...
    def checkout(self, force: bool = ..., **kwargs: Any) -> Union[HEAD, Head]:
        """Checkout this head by setting the HEAD to this reference, by updating the index
        to reflect the tree we point to and by updating the working tree to reflect
        the latest index.

        The command will fail if changed working tree files would be overwritten.

        :param force:
            If True, changes to the index and the working tree will be discarded.
            If False, GitCommandError will be raised in that situation.

        :param kwargs:
            Additional keyword arguments to be passed to git checkout, i.e.
            b='new_branch' to create a new branch at the given spot.

        :return:
            The active branch after the checkout operation, usually self unless
            a new branch has been created.
            If there is no active branch, as the HEAD is now detached, the HEAD
            reference will be returned instead.

        :note:
            By default it is only allowed to checkout heads - everything else
            will leave the HEAD detached which is allowed and possible, but remains
            a special state that some tools might not be able to handle."""
        ...
    def config_reader(self) -> SectionConstraint[GitConfigParser]:
        """
        :return: A configuration parser instance constrained to only read
            this instance's values"""
        ...
    def config_writer(self) -> SectionConstraint[GitConfigParser]:
        """
        :return: A configuration writer instance with read-and write access
            to options of this head"""
        ...
