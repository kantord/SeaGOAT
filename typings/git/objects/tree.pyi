"""
This type stub file was generated by pyright.
"""

import git.diff as git_diff
from git.util import IterableList
from . import util
from .base import IndexObjUnion, IndexObject
from .blob import Blob
from typing import (
    Any,
    Callable,
    Dict,
    Iterator,
    List,
    TYPE_CHECKING,
    Tuple,
    Type,
    Union,
)
from git.types import Literal, PathLike
from git.repo import Repo

if TYPE_CHECKING: ...
TreeCacheTup = Tuple[bytes, int, str]
TraversedTreeTup = Union[
    Tuple[Union["Tree", None], IndexObjUnion, Tuple["Submodule", "Submodule"]]
]
cmp: Callable[[str, str], int] = ...
__all__ = ("TreeModifier", "Tree")

def git_cmp(t1: TreeCacheTup, t2: TreeCacheTup) -> int: ...
def merge_sort(
    a: List[TreeCacheTup], cmp: Callable[[TreeCacheTup, TreeCacheTup], int]
) -> None: ...

class TreeModifier:
    """A utility class providing methods to alter the underlying cache in a list-like fashion.

    Once all adjustments are complete, the _cache, which really is a reference to
    the cache of a tree, will be sorted. Assuring it will be in a serializable state"""

    __slots__ = ...
    def __init__(self, cache: List[TreeCacheTup]) -> None: ...
    def set_done(self) -> TreeModifier:
        """Call this method once you are done modifying the tree information.
        It may be called several times, but be aware that each call will cause
        a sort operation

        :return self:"""
        ...
    def add(self, sha: bytes, mode: int, name: str, force: bool = ...) -> TreeModifier:
        """Add the given item to the tree. If an item with the given name already
        exists, nothing will be done, but a ValueError will be raised if the
        sha and mode of the existing item do not match the one you add, unless
        force is True

        :param sha: The 20 or 40 byte sha of the item to add
        :param mode: int representing the stat compatible mode of the item
        :param force: If True, an item with your name and information will overwrite
            any existing item with the same name, no matter which information it has
        :return: self"""
        ...
    def add_unchecked(self, binsha: bytes, mode: int, name: str) -> None:
        """Add the given item to the tree, its correctness is assumed, which
        puts the caller into responsibility to assure the input is correct.
        For more information on the parameters, see ``add``

        :param binsha: 20 byte binary sha"""
        ...
    def __delitem__(self, name: str) -> None:
        """Deletes an item with the given name if it exists"""
        ...

class Tree(IndexObject, git_diff.Diffable, util.Traversable, util.Serializable):
    """Tree objects represent an ordered list of Blobs and other Trees.

    ``Tree as a list``::

        Access a specific blob using the
        tree['filename'] notation.

        You may as well access by index
        blob = tree[0]
    """

    type: Literal[tree] = ...
    __slots__ = ...
    commit_id = ...
    blob_id = ...
    symlink_id = ...
    tree_id = ...
    _map_id_to_type: Dict[int, Type[IndexObjUnion]] = ...
    def __init__(
        self,
        repo: Repo,
        binsha: bytes,
        mode: int = ...,
        path: Union[PathLike, None] = ...,
    ) -> None: ...
    def join(self, file: str) -> IndexObjUnion:
        """Find the named object in this tree's contents

        :return: ``git.Blob`` or ``git.Tree`` or ``git.Submodule``
        :raise KeyError: if given file or tree does not exist in tree"""
        ...
    def __truediv__(self, file: str) -> IndexObjUnion:
        """For PY3 only"""
        ...
    @property
    def trees(self) -> List[Tree]:
        """:return: list(Tree, ...) list of trees directly below this tree"""
        ...
    @property
    def blobs(self) -> List[Blob]:
        """:return: list(Blob, ...) list of blobs directly below this tree"""
        ...
    @property
    def cache(self) -> TreeModifier:
        """
        :return: An object allowing to modify the internal cache. This can be used
            to change the tree's contents. When done, make sure you call ``set_done``
            on the tree modifier, or serialization behaviour will be incorrect.
            See the ``TreeModifier`` for more information on how to alter the cache"""
        ...
    def traverse(
        self,
        predicate: Callable[[Union[IndexObjUnion, TraversedTreeTup], int], bool] = ...,
        prune: Callable[[Union[IndexObjUnion, TraversedTreeTup], int], bool] = ...,
        depth: int = ...,
        branch_first: bool = ...,
        visit_once: bool = ...,
        ignore_self: int = ...,
        as_edge: bool = ...,
    ) -> Union[Iterator[IndexObjUnion], Iterator[TraversedTreeTup]]:
        """For documentation, see util.Traversable._traverse()
        Trees are set to visit_once = False to gain more performance in the traversal"""
        ...
    def list_traverse(self, *args: Any, **kwargs: Any) -> IterableList[IndexObjUnion]:
        """
        :return: IterableList with the results of the traversal as produced by
            traverse()
            Tree -> IterableList[Union['Submodule', 'Tree', 'Blob']]
        """
        ...
    def __getslice__(self, i: int, j: int) -> List[IndexObjUnion]: ...
    def __iter__(self) -> Iterator[IndexObjUnion]: ...
    def __len__(self) -> int: ...
    def __getitem__(self, item: Union[str, int, slice]) -> IndexObjUnion: ...
    def __contains__(self, item: Union[IndexObjUnion, PathLike]) -> bool: ...
    def __reversed__(self) -> Iterator[IndexObjUnion]: ...
