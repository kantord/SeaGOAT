"""
This type stub file was generated by pyright.
"""

from abc import abstractmethod
from git.util import Actor, IterableList, IterableObj
from datetime import datetime, timedelta, tzinfo
from typing import (
    Any,
    Callable,
    Iterator,
    NamedTuple,
    TYPE_CHECKING,
    Tuple,
    Type,
    TypeVar,
    Union,
    overload,
)
from git.types import Literal, Protocol, runtime_checkable
from .commit import Commit
from .blob import Blob
from .tag import TagObject
from .tree import Tree
from subprocess import Popen

"""Module for general utility functions"""
if TYPE_CHECKING: ...
else: ...

class TraverseNT(NamedTuple):
    depth: int
    item: Union[Traversable, Blob]
    src: Union[Traversable, None]
    ...

T_TIobj = TypeVar("T_TIobj", bound="TraversableIterableObj")
TraversedTup = Union[
    Tuple[Union["Traversable", None], "Traversable"],
    "TraversedTreeTup",
]
__all__ = (
    "get_object_type_by_name",
    "parse_date",
    "parse_actor_and_date",
    "ProcessStreamAdapter",
    "Traversable",
    "altz_to_utctz_str",
    "utctz_to_altz",
    "verify_utctz",
    "Actor",
    "tzoffset",
    "utc",
)
ZERO = ...

def mode_str_to_int(modestr: Union[bytes, str]) -> int:
    """
    :param modestr: string like 755 or 644 or 100644 - only the last 6 chars will be used
    :return:
        String identifying a mode compatible to the mode methods ids of the
        stat module regarding the rwx permissions for user, group and other,
        special flags and file system flags, i.e. whether it is a symlink
        for example."""
    ...

def get_object_type_by_name(
    object_type_name: bytes,
) -> Union[Type[Commit], Type[TagObject], Type[Tree], Type[Blob]]:
    """
    :return: type suitable to handle the given object type name.
        Use the type to create new instances.

    :param object_type_name: Member of TYPES

    :raise ValueError: In case object_type_name is unknown"""
    ...

def utctz_to_altz(utctz: str) -> int:
    """Convert a git timezone offset into a timezone offset west of
    UTC in seconds (compatible with time.altzone).

    :param utctz: git utc timezone string, i.e. +0200
    """
    ...

def altz_to_utctz_str(altz: int) -> str:
    """Convert a timezone offset west of UTC in seconds into a git timezone offset string

    :param altz: timezone offset in seconds west of UTC
    """
    ...

def verify_utctz(offset: str) -> str:
    """:raise ValueError: if offset is incorrect
    :return: offset"""
    ...

class tzoffset(tzinfo):
    def __init__(
        self, secs_west_of_utc: float, name: Union[None, str] = ...
    ) -> None: ...
    def __reduce__(self) -> Tuple[Type[tzoffset], Tuple[float, str]]: ...
    def utcoffset(self, dt: Union[datetime, None]) -> timedelta: ...
    def tzname(self, dt: Union[datetime, None]) -> str: ...
    def dst(self, dt: Union[datetime, None]) -> timedelta: ...

utc = ...

def from_timestamp(timestamp: float, tz_offset: float) -> datetime:
    """Converts a timestamp + tz_offset into an aware datetime instance."""
    ...

def parse_date(string_date: Union[str, datetime]) -> Tuple[int, int]:
    """
    Parse the given date as one of the following

        * aware datetime instance
        * Git internal format: timestamp offset
        * RFC 2822: Thu, 07 Apr 2005 22:13:13 +0200.
        * ISO 8601 2005-04-07T22:13:13
            The T can be a space as well

    :return: Tuple(int(timestamp_UTC), int(offset)), both in seconds since epoch
    :raise ValueError: If the format could not be understood
    :note: Date can also be YYYY.MM.DD, MM/DD/YYYY and DD.MM.YYYY.
    """
    ...

_re_actor_epoch = ...
_re_only_actor = ...

def parse_actor_and_date(line: str) -> Tuple[Actor, int, int]:
    """Parse out the actor (author or committer) info from a line like::

        author Tom Preston-Werner <tom@mojombo.com> 1191999972 -0700

    :return: [Actor, int_seconds_since_epoch, int_timezone_offset]"""
    ...

class ProcessStreamAdapter:
    """Class wireing all calls to the contained Process instance.

    Use this type to hide the underlying process to provide access only to a specified
    stream. The process is usually wrapped into an AutoInterrupt class to kill
    it if the instance goes out of scope."""

    __slots__ = ...
    def __init__(self, process: Popen, stream_name: str) -> None: ...
    def __getattr__(self, attr: str) -> Any: ...

@runtime_checkable
class Traversable(Protocol):
    """Simple interface to perform depth-first or breadth-first traversals
    into one direction.
    Subclasses only need to implement one function.
    Instances of the Subclass must be hashable

    Defined subclasses = [Commit, Tree, SubModule]
    """

    __slots__ = ...
    @abstractmethod
    def list_traverse(self, *args: Any, **kwargs: Any) -> Any:
        """ """
        ...
    @abstractmethod
    def traverse(self, *args: Any, **kwargs: Any) -> Any:
        """ """
        ...

@runtime_checkable
class Serializable(Protocol):
    """Defines methods to serialize and deserialize objects from and into a data stream"""

    __slots__ = ...

class TraversableIterableObj(IterableObj, Traversable):
    __slots__ = ...
    TIobj_tuple = Tuple[Union[T_TIobj, None], T_TIobj]
    def list_traverse(
        self: T_TIobj, *args: Any, **kwargs: Any
    ) -> IterableList[T_TIobj]: ...
    @overload
    def traverse(self: T_TIobj) -> Iterator[T_TIobj]: ...
    @overload
    def traverse(
        self: T_TIobj,
        predicate: Callable[
            [Union[T_TIobj, Tuple[Union[T_TIobj, None], T_TIobj]], int], bool
        ],
        prune: Callable[
            [Union[T_TIobj, Tuple[Union[T_TIobj, None], T_TIobj]], int], bool
        ],
        depth: int,
        branch_first: bool,
        visit_once: bool,
        ignore_self: Literal[True],
        as_edge: Literal[False],
    ) -> Iterator[T_TIobj]: ...
    @overload
    def traverse(
        self: T_TIobj,
        predicate: Callable[
            [Union[T_TIobj, Tuple[Union[T_TIobj, None], T_TIobj]], int], bool
        ],
        prune: Callable[
            [Union[T_TIobj, Tuple[Union[T_TIobj, None], T_TIobj]], int], bool
        ],
        depth: int,
        branch_first: bool,
        visit_once: bool,
        ignore_self: Literal[False],
        as_edge: Literal[True],
    ) -> Iterator[Tuple[Union[T_TIobj, None], T_TIobj]]: ...
    @overload
    def traverse(
        self: T_TIobj,
        predicate: Callable[[Union[T_TIobj, TIobj_tuple], int], bool],
        prune: Callable[[Union[T_TIobj, TIobj_tuple], int], bool],
        depth: int,
        branch_first: bool,
        visit_once: bool,
        ignore_self: Literal[True],
        as_edge: Literal[True],
    ) -> Iterator[Tuple[T_TIobj, T_TIobj]]: ...
    def traverse(
        self: T_TIobj,
        predicate: Callable[[Union[T_TIobj, TIobj_tuple], int], bool] = ...,
        prune: Callable[[Union[T_TIobj, TIobj_tuple], int], bool] = ...,
        depth: int = ...,
        branch_first: bool = ...,
        visit_once: bool = ...,
        ignore_self: int = ...,
        as_edge: bool = ...,
    ) -> Union[
        Iterator[T_TIobj], Iterator[Tuple[T_TIobj, T_TIobj]], Iterator[TIobj_tuple]
    ]:
        """For documentation, see util.Traversable._traverse()"""
        ...
