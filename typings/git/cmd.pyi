"""
This type stub file was generated by pyright.
"""

import subprocess
from contextlib import contextmanager
from subprocess import Popen
from .util import LazyMixin
from typing import (
    Any,
    AnyStr,
    BinaryIO,
    Callable,
    Dict,
    IO,
    Iterator,
    List,
    Mapping,
    Sequence,
    TYPE_CHECKING,
    Tuple,
    Union,
    overload,
)
from git.types import Literal, PathLike
from git.repo.base import Repo
from git.diff import DiffIndex

if TYPE_CHECKING: ...
execute_kwargs = ...
log = ...
__all__ = ("Git",)

def handle_process_output(
    process: Git.AutoInterrupt | Popen,
    stdout_handler: Union[
        None,
        Callable[[AnyStr], None],
        Callable[[List[AnyStr]], None],
        Callable[[bytes, Repo, DiffIndex], None],
    ],
    stderr_handler: Union[
        None, Callable[[AnyStr], None], Callable[[List[AnyStr]], None]
    ],
    finalizer: Union[
        None, Callable[[Union[subprocess.Popen, Git.AutoInterrupt]], None]
    ] = ...,
    decode_streams: bool = ...,
    kill_after_timeout: Union[None, float] = ...,
) -> None:
    """Registers for notifications to learn that process output is ready to read, and dispatches lines to
    the respective line handlers.
    This function returns once the finalizer returns

    :return: result of finalizer
    :param process: subprocess.Popen instance
    :param stdout_handler: f(stdout_line_string), or None
    :param stderr_handler: f(stderr_line_string), or None
    :param finalizer: f(proc) - wait for proc to finish
    :param decode_streams:
        Assume stdout/stderr streams are binary and decode them before pushing \
        their contents to handlers.
        Set it to False if `universal_newline == True` (then streams are in text-mode)
        or if decoding must happen later (i.e. for Diffs).
    :param kill_after_timeout:
        float or None, Default = None
        To specify a timeout in seconds for the git command, after which the process
        should be killed.
    """
    ...

def dashify(string: str) -> str: ...
def slots_to_dict(self: object, exclude: Sequence[str] = ...) -> Dict[str, Any]: ...
def dict_to_slots_and__excluded_are_none(
    self: object, d: Mapping[str, Any], excluded: Sequence[str] = ...
) -> None: ...

CREATE_NO_WINDOW = ...
PROC_CREATIONFLAGS = ...

class Git(LazyMixin):
    """
    The Git class manages communication with the Git binary.

    It provides a convenient interface to calling the Git binary, such as in::

     g = Git( git_dir )
     g.init()                   # calls 'git init' program
     rval = g.ls_files()        # calls 'git ls-files' program

    ``Debugging``
        Set the GIT_PYTHON_TRACE environment variable print each invocation
        of the command to stdout.
        Set its value to 'full' to see details about the returned values.
    """

    __slots__ = ...
    _excluded_ = ...
    re_unsafe_protocol = ...
    def __getstate__(self) -> Dict[str, Any]: ...
    def __setstate__(self, d: Dict[str, Any]) -> None: ...

    git_exec_name = ...
    GIT_PYTHON_TRACE = ...
    USE_SHELL = ...
    _git_exec_env_var = ...
    _refresh_env_var = ...
    GIT_PYTHON_GIT_EXECUTABLE = ...
    @classmethod
    def refresh(cls, path: Union[None, PathLike] = ...) -> bool:
        """This gets called by the refresh function (see the top level
        __init__).
        """
        ...
    @classmethod
    def is_cygwin(cls) -> bool: ...
    @overload
    @classmethod
    def polish_url(cls, url: str, is_cygwin: Literal[False] = ...) -> str: ...
    @overload
    @classmethod
    def polish_url(cls, url: str, is_cygwin: Union[None, bool] = ...) -> str: ...
    @classmethod
    def polish_url(cls, url: str, is_cygwin: Union[None, bool] = ...) -> PathLike: ...
    @classmethod
    def check_unsafe_protocols(cls, url: str) -> None:
        """
        Check for unsafe protocols.

        Apart from the usual protocols (http, git, ssh),
        Git allows "remote helpers" that have the form `<transport>::<address>`,
        one of these helpers (`ext::`) can be used to invoke any arbitrary command.

        See:

        - https://git-scm.com/docs/gitremote-helpers
        - https://git-scm.com/docs/git-remote-ext
        """
        ...
    @classmethod
    def check_unsafe_options(
        cls, options: List[str], unsafe_options: List[str]
    ) -> None:
        """
        Check for unsafe options.

        Some options that are passed to `git <command>` can be used to execute
        arbitrary commands, this are blocked by default.
        """
        ...

    class AutoInterrupt:
        """Kill/Interrupt the stored process instance once this instance goes out of scope. It is
        used to prevent processes piling up in case iterators stop reading.
        Besides all attributes are wired through to the contained process object.

        The wait method was overridden to perform automatic status code checking
        and possibly raise."""

        __slots__ = ...
        _status_code_if_terminate: int = ...
        def __init__(self, proc: Union[None, subprocess.Popen], args: Any) -> None: ...
        def __del__(self) -> None: ...
        def __getattr__(self, attr: str) -> Any: ...
        def wait(self, stderr: Union[None, str, bytes] = ...) -> int:
            """Wait for the process and return its status code.

            :param stderr: Previously read value of stderr, in case stderr is already closed.
            :warn: may deadlock if output or error pipes are used and not handled separately.
            :raise GitCommandError: if the return status is not 0"""
            ...

    class CatFileContentStream:
        """Object representing a sized read-only stream returning the contents of
        an object.
        It behaves like a stream, but counts the data read and simulates an empty
        stream once our sized content region is empty.
        If not all data is read to the end of the objects's lifetime, we read the
        rest to assure the underlying stream continues to work"""

        __slots__: Tuple[str, ...] = ...
        def __init__(self, size: int, stream: IO[bytes]) -> None: ...
        def read(self, size: int = ...) -> bytes: ...
        def readline(self, size: int = ...) -> bytes: ...
        def readlines(self, size: int = ...) -> List[bytes]: ...
        def __iter__(self) -> Git.CatFileContentStream: ...
        def __next__(self) -> bytes: ...

        next = ...
        def __del__(self) -> None: ...

    def __init__(self, working_dir: Union[None, PathLike] = ...) -> None:
        """Initialize this instance with:

        :param working_dir:
           Git directory we should work in. If None, we always work in the current
           directory as returned by os.getcwd().
           It is meant to be the working tree directory if available, or the
           .git directory in case of bare repositories."""
        ...
    def __getattr__(self, name: str) -> Any:
        """A convenience method as it allows to call the command as if it was
        an object.

        :return: Callable object that will execute call _call_process with your arguments.
        """
        ...
    def set_persistent_git_options(self, **kwargs: Any) -> None:
        """Specify command line options to the git executable
        for subsequent subcommand calls

        :param kwargs:
            is a dict of keyword arguments.
            these arguments are passed as in _call_process
            but will be passed to the git command rather than
            the subcommand.
        """
        ...
    @property
    def working_dir(self) -> Union[None, PathLike]:
        """:return: Git directory we are working on"""
        ...
    @property
    def version_info(self) -> Tuple[int, int, int, int]:
        """
        :return: tuple(int, int, int, int) tuple with integers representing the major, minor
            and additional version numbers as parsed from git version.
            This value is generated on demand and is cached"""
        ...
    @overload
    def execute(
        self, command: Union[str, Sequence[Any]], *, as_process: Literal[True]
    ) -> AutoInterrupt: ...
    @overload
    def execute(
        self,
        command: Union[str, Sequence[Any]],
        *,
        as_process: Literal[False] = ...,
        stdout_as_string: Literal[True]
    ) -> Union[str, Tuple[int, str, str]]: ...
    @overload
    def execute(
        self,
        command: Union[str, Sequence[Any]],
        *,
        as_process: Literal[False] = ...,
        stdout_as_string: Literal[False] = ...
    ) -> Union[bytes, Tuple[int, bytes, str]]: ...
    @overload
    def execute(
        self,
        command: Union[str, Sequence[Any]],
        *,
        with_extended_output: Literal[False],
        as_process: Literal[False],
        stdout_as_string: Literal[True]
    ) -> str: ...
    @overload
    def execute(
        self,
        command: Union[str, Sequence[Any]],
        *,
        with_extended_output: Literal[False],
        as_process: Literal[False],
        stdout_as_string: Literal[False]
    ) -> bytes: ...
    def execute(
        self,
        command: Union[str, Sequence[Any]],
        istream: Union[None, BinaryIO] = ...,
        with_extended_output: bool = ...,
        with_exceptions: bool = ...,
        as_process: bool = ...,
        output_stream: Union[None, BinaryIO] = ...,
        stdout_as_string: bool = ...,
        kill_after_timeout: Union[None, float] = ...,
        with_stdout: bool = ...,
        universal_newlines: bool = ...,
        shell: Union[None, bool] = ...,
        env: Union[None, Mapping[str, str]] = ...,
        max_chunk_size: int = ...,
        strip_newline_in_stdout: bool = ...,
        **subprocess_kwargs: Any
    ) -> Union[str, bytes, Tuple[int, Union[str, bytes], str], AutoInterrupt]:
        """Handles executing the command on the shell and consumes and returns
        the returned information (stdout)

        :param command:
            The command argument list to execute.
            It should be a string, or a sequence of program arguments. The
            program to execute is the first item in the args sequence or string.

        :param istream:
            Standard input filehandle passed to subprocess.Popen.

        :param with_extended_output:
            Whether to return a (status, stdout, stderr) tuple.

        :param with_exceptions:
            Whether to raise an exception when git returns a non-zero status.

        :param as_process:
            Whether to return the created process instance directly from which
            streams can be read on demand. This will render with_extended_output and
            with_exceptions ineffective - the caller will have
            to deal with the details himself.
            It is important to note that the process will be placed into an AutoInterrupt
            wrapper that will interrupt the process once it goes out of scope. If you
            use the command in iterators, you should pass the whole process instance
            instead of a single stream.

        :param output_stream:
            If set to a file-like object, data produced by the git command will be
            output to the given stream directly.
            This feature only has any effect if as_process is False. Processes will
            always be created with a pipe due to issues with subprocess.
            This merely is a workaround as data will be copied from the
            output pipe to the given output stream directly.
            Judging from the implementation, you shouldn't use this flag !

        :param stdout_as_string:
            if False, the commands standard output will be bytes. Otherwise, it will be
            decoded into a string using the default encoding (usually utf-8).
            The latter can fail, if the output contains binary data.

        :param env:
            A dictionary of environment variables to be passed to `subprocess.Popen`.

        :param max_chunk_size:
            Maximum number of bytes in one chunk of data passed to the output_stream in
            one invocation of write() method. If the given number is not positive then
            the default value is used.

        :param subprocess_kwargs:
            Keyword arguments to be passed to subprocess.Popen. Please note that
            some of the valid kwargs are already set by this method, the ones you
            specify may not be the same ones.

        :param with_stdout: If True, default True, we open stdout on the created process
        :param universal_newlines:
            if True, pipes will be opened as text, and lines are split at
            all known line endings.
        :param shell:
            Whether to invoke commands through a shell (see `Popen(..., shell=True)`).
            It overrides :attr:`USE_SHELL` if it is not `None`.
        :param kill_after_timeout:
            To specify a timeout in seconds for the git command, after which the process
            should be killed. This will have no effect if as_process is set to True. It is
            set to None by default and will let the process run until the timeout is
            explicitly specified. This feature is not supported on Windows. It's also worth
            noting that kill_after_timeout uses SIGKILL, which can have negative side
            effects on a repository. For example, stale locks in case of git gc could
            render the repository incapable of accepting changes until the lock is manually
            removed.
        :param strip_newline_in_stdout:
            Whether to strip the trailing ``\\n`` of the command stdout.
        :return:
            * str(output) if extended_output = False (Default)
            * tuple(int(status), str(stdout), str(stderr)) if extended_output = True

            if output_stream is True, the stdout value will be your output stream:
            * output_stream if extended_output = False
            * tuple(int(status), output_stream, str(stderr)) if extended_output = True

            Note git is executed with LC_MESSAGES="C" to ensure consistent
            output regardless of system language.

        :raise GitCommandError:

        :note:
           If you add additional keyword arguments to the signature of this method,
           you must update the execute_kwargs tuple housed in this module."""
        ...
    def environment(self) -> Dict[str, str]: ...
    def update_environment(self, **kwargs: Any) -> Dict[str, Union[str, None]]:
        """
        Set environment variables for future git invocations. Return all changed
        values in a format that can be passed back into this function to revert
        the changes:

        ``Examples``::

            old_env = self.update_environment(PWD='/tmp')
            self.update_environment(**old_env)

        :param kwargs: environment variables to use for git processes
        :return: dict that maps environment variables to their old values
        """
        ...
    @contextmanager
    def custom_environment(self, **kwargs: Any) -> Iterator[None]:
        """
        A context manager around the above ``update_environment`` method to restore the
        environment back to its previous state after operation.

        ``Examples``::

            with self.custom_environment(GIT_SSH='/bin/ssh_wrapper'):
                repo.remotes.origin.fetch()

        :param kwargs: see update_environment
        """
        ...
    def transform_kwarg(
        self, name: str, value: Any, split_single_char_options: bool
    ) -> List[str]: ...
    def transform_kwargs(
        self, split_single_char_options: bool = ..., **kwargs: Any
    ) -> List[str]:
        """Transforms Python style kwargs into git command line options."""
        ...
    def __call__(self, **kwargs: Any) -> Git:
        """Specify command line options to the git executable
        for a subcommand call

        :param kwargs:
            is a dict of keyword arguments.
            these arguments are passed as in _call_process
            but will be passed to the git command rather than
            the subcommand.

        ``Examples``::
            git(work_tree='/tmp').difftool()"""
        ...
    def get_object_header(self, ref: str) -> Tuple[str, str, int]:
        """Use this method to quickly examine the type and size of the object behind
        the given ref.

        :note: The method will only suffer from the costs of command invocation
            once and reuses the command in subsequent calls.

        :return: (hexsha, type_string, size_as_int)"""
        ...
    def get_object_data(self, ref: str) -> Tuple[str, str, int, bytes]:
        """As get_object_header, but returns object data as well

        :return: (hexsha, type_string, size_as_int, data_string)
        :note: not threadsafe"""
        ...
    def stream_object_data(
        self, ref: str
    ) -> Tuple[str, str, int, Git.CatFileContentStream]:
        """As get_object_header, but returns the data as a stream

        :return: (hexsha, type_string, size_as_int, stream)
        :note: This method is not threadsafe, you need one independent Command instance per thread to be safe !
        """
        ...
    def clear_cache(self) -> Git:
        """Clear all kinds of internal caches to release resources.

        Currently persistent commands will be interrupted.

        :return: self"""
        ...
