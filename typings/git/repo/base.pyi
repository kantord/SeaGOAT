"""
This type stub file was generated by pyright.
"""

from gitdb.db.loose import LooseObjectDB
from git.cmd import Git
from git.config import GitConfigParser
from git.db import GitCmdObjectDB
from git.index import IndexFile
from git.objects import Commit, Submodule, Tree
from git.refs import HEAD, Head, Reference, TagReference
from git.remote import Remote
from git.util import IterableList
from .fun import rev_parse
from git.types import (
    Commit_ish,
    ConfigLevels_Tup,
    Lit_config_levels,
    PathLike,
    TBD,
    Tree_ish,
    TypedDict,
)
from typing import (
    Any,
    BinaryIO,
    Callable,
    Dict,
    Iterator,
    List,
    Mapping,
    NamedTuple,
    Optional,
    Sequence,
    TYPE_CHECKING,
    TextIO,
    Type,
    Union,
)
from git.refs.symbolic import SymbolicReference

if TYPE_CHECKING: ...
log = ...
__all__ = ("Repo",)

class BlameEntry(NamedTuple):
    commit: Dict[str, Commit]
    linenos: range
    orig_path: Optional[str]
    orig_linenos: range
    ...

class Repo:
    """Represents a git repository and allows you to query references,
    gather commit information, generate diffs, create and clone repositories query
    the log.

    The following attributes are worth using:

    'working_dir' is the working directory of the git command, which is the working tree
    directory if available or the .git directory in case of bare repositories

    'working_tree_dir' is the working tree directory, but will return None
    if we are a bare repository.

    'git_dir' is the .git repository directory, which is always set."""

    DAEMON_EXPORT_FILE = ...
    git = ...
    working_dir: PathLike
    _working_tree_dir: Optional[PathLike] = ...
    git_dir: PathLike
    _common_dir: PathLike = ...
    re_whitespace = ...
    re_hexsha_only = ...
    re_hexsha_shortened = ...
    re_envvars = ...
    re_author_committer_start = ...
    re_tab_full_line = ...
    unsafe_git_clone_options = ...
    config_level: ConfigLevels_Tup = ...
    GitCommandWrapperType = Git
    def __init__(
        self,
        path: Optional[PathLike] = ...,
        odbt: Type[LooseObjectDB] = ...,
        search_parent_directories: bool = ...,
        expand_vars: bool = ...,
    ) -> None:
        """Create a new Repo instance

        :param path:
            the path to either the root git directory or the bare git repo::

                repo = Repo("/Users/mtrier/Development/git-python")
                repo = Repo("/Users/mtrier/Development/git-python.git")
                repo = Repo("~/Development/git-python.git")
                repo = Repo("$REPOSITORIES/Development/git-python.git")
                repo = Repo("C:\\Users\\mtrier\\Development\\git-python\\.git")

            - In *Cygwin*, path may be a `'cygdrive/...'` prefixed path.
            - If it evaluates to false, :envvar:`GIT_DIR` is used, and if this also evals to false,
              the current-directory is used.
        :param odbt:
            Object DataBase type - a type which is constructed by providing
            the directory containing the database objects, i.e. .git/objects. It will
            be used to access all object data
        :param search_parent_directories:
            if True, all parent directories will be searched for a valid repo as well.

            Please note that this was the default behaviour in older versions of GitPython,
            which is considered a bug though.
        :raise InvalidGitRepositoryError:
        :raise NoSuchPathError:
        :return: git.Repo"""
        ...
    def __enter__(self) -> Repo: ...
    def __exit__(self, *args: Any) -> None: ...
    def __del__(self) -> None: ...
    def close(self) -> None: ...
    def __eq__(self, rhs: object) -> bool: ...
    def __ne__(self, rhs: object) -> bool: ...
    def __hash__(self) -> int: ...

    description = ...
    @property
    def working_tree_dir(self) -> Optional[PathLike]:
        """:return: The working tree directory of our git repository. If this is a bare repository, None is returned."""
        ...
    @property
    def common_dir(self) -> PathLike:
        """
        :return: The git dir that holds everything except possibly HEAD,
            FETCH_HEAD, ORIG_HEAD, COMMIT_EDITMSG, index, and logs/."""
        ...
    @property
    def bare(self) -> bool:
        """:return: True if the repository is bare"""
        ...
    @property
    def heads(self) -> IterableList[Head]:
        """A list of ``Head`` objects representing the branch heads in
        this repo

        :return: ``git.IterableList(Head, ...)``"""
        ...
    @property
    def references(self) -> IterableList[Reference]:
        """A list of Reference objects representing tags, heads and remote references.

        :return: IterableList(Reference, ...)"""
        ...
    refs = ...
    branches = ...
    @property
    def index(self) -> IndexFile:
        """:return: IndexFile representing this repository's index.
        :note: This property can be expensive, as the returned ``IndexFile`` will be
         reinitialized. It's recommended to re-use the object."""
        ...
    @property
    def head(self) -> HEAD:
        """:return: HEAD Object pointing to the current head reference"""
        ...
    @property
    def remotes(self) -> IterableList[Remote]:
        """A list of Remote objects allowing to access and manipulate remotes

        :return: ``git.IterableList(Remote, ...)``"""
        ...
    def remote(self, name: str = ...) -> Remote:
        """:return: Remote with the specified name
        :raise ValueError:  if no remote with such a name exists"""
        ...
    @property
    def submodules(self) -> IterableList[Submodule]:
        """
        :return: git.IterableList(Submodule, ...) of direct submodules
            available from the current head"""
        ...
    def submodule(self, name: str) -> Submodule:
        """:return: Submodule with the given name
        :raise ValueError: If no such submodule exists"""
        ...
    def create_submodule(self, *args: Any, **kwargs: Any) -> Submodule:
        """Create a new submodule

        :note: See the documentation of Submodule.add for a description of the
            applicable parameters
        :return: created submodules"""
        ...
    def iter_submodules(self, *args: Any, **kwargs: Any) -> Iterator[Submodule]:
        """An iterator yielding Submodule instances, see Traversable interface
        for a description of args and kwargs

        :return: Iterator"""
        ...
    def submodule_update(self, *args: Any, **kwargs: Any) -> Iterator[Submodule]:
        """Update the submodules, keeping the repository consistent as it will
        take the previous state into consideration. For more information, please
        see the documentation of RootModule.update"""
        ...
    @property
    def tags(self) -> IterableList[TagReference]:
        """A list of ``Tag`` objects that are available in this repo

        :return: ``git.IterableList(TagReference, ...)``"""
        ...
    def tag(self, path: PathLike) -> TagReference:
        """:return: TagReference Object, reference pointing to a Commit or Tag
        :param path: path to the tag reference, i.e. 0.1.5 or tags/0.1.5"""
        ...
    def create_head(
        self,
        path: PathLike,
        commit: Union[SymbolicReference, str] = ...,
        force: bool = ...,
        logmsg: Optional[str] = ...,
    ) -> Head:
        """Create a new head within the repository.
        For more documentation, please see the Head.create method.

        :return: newly created Head Reference"""
        ...
    def delete_head(self, *heads: Union[str, Head], **kwargs: Any) -> None:
        """Delete the given heads

        :param kwargs: Additional keyword arguments to be passed to git-branch"""
        ...
    def create_tag(
        self,
        path: PathLike,
        ref: Union[str, SymbolicReference] = ...,
        message: Optional[str] = ...,
        force: bool = ...,
        **kwargs: Any
    ) -> TagReference:
        """Create a new tag reference.
        For more documentation, please see the TagReference.create method.

        :return: TagReference object"""
        ...
    def delete_tag(self, *tags: TagReference) -> None:
        """Delete the given tag references"""
        ...
    def create_remote(self, name: str, url: str, **kwargs: Any) -> Remote:
        """Create a new remote.

        For more information, please see the documentation of the Remote.create
        methods

        :return: Remote reference"""
        ...
    def delete_remote(self, remote: Remote) -> str:
        """Delete the given remote."""
        ...
    def config_reader(
        self, config_level: Optional[Lit_config_levels] = ...
    ) -> GitConfigParser:
        """
        :return:
            GitConfigParser allowing to read the full git configuration, but not to write it

            The configuration will include values from the system, user and repository
            configuration files.

        :param config_level:
            For possible values, see config_writer method
            If None, all applicable levels will be used. Specify a level in case
            you know which file you wish to read to prevent reading multiple files.
        :note: On windows, system configuration cannot currently be read as the path is
            unknown, instead the global path will be used."""
        ...
    def config_writer(self, config_level: Lit_config_levels = ...) -> GitConfigParser:
        """
        :return:
            GitConfigParser allowing to write values of the specified configuration file level.
            Config writers should be retrieved, used to change the configuration, and written
            right away as they will lock the configuration file in question and prevent other's
            to write it.

        :param config_level:
            One of the following values
            system = system wide configuration file
            global = user level configuration file
            repository = configuration file for this repository only"""
        ...
    def commit(self, rev: Union[str, Commit_ish, None] = ...) -> Commit:
        """The Commit object for the specified revision

        :param rev: revision specifier, see git-rev-parse for viable options.
        :return: ``git.Commit``
        """
        ...
    def iter_trees(self, *args: Any, **kwargs: Any) -> Iterator[Tree]:
        """:return: Iterator yielding Tree objects
        :note: Takes all arguments known to iter_commits method"""
        ...
    def tree(self, rev: Union[Tree_ish, str, None] = ...) -> Tree:
        """The Tree object for the given treeish revision
        Examples::

              repo.tree(repo.heads[0])

        :param rev: is a revision pointing to a Treeish ( being a commit or tree )
        :return: ``git.Tree``

        :note:
            If you need a non-root level tree, find it by iterating the root tree. Otherwise
            it cannot know about its path relative to the repository root and subsequent
            operations might have unexpected results."""
        ...
    def iter_commits(
        self,
        rev: Union[str, Commit, SymbolicReference, None] = ...,
        paths: Union[PathLike, Sequence[PathLike]] = ...,
        **kwargs: Any
    ) -> Iterator[Commit]:
        """A list of Commit objects representing the history of a given ref/commit

        :param rev:
            revision specifier, see git-rev-parse for viable options.
            If None, the active branch will be used.

        :param paths:
            is an optional path or a list of paths; if set only commits that include the path
            or paths will be returned

        :param kwargs:
            Arguments to be passed to git-rev-list - common ones are
            max_count and skip

        :note: to receive only commits between two named revisions, use the
            "revA...revB" revision specifier

        :return: ``git.Commit[]``"""
        ...
    def merge_base(self, *rev: TBD, **kwargs: Any) -> List[Union[Commit_ish, None]]:
        """Find the closest common ancestor for the given revision (e.g. Commits, Tags, References, etc)

        :param rev: At least two revs to find the common ancestor for.
        :param kwargs: Additional arguments to be passed to the repo.git.merge_base() command which does all the work.
        :return: A list of Commit objects. If --all was not specified as kwarg, the list will have at max one Commit,
            or is empty if no common merge base exists.
        :raises ValueError: If not at least two revs are provided
        """
        ...
    def is_ancestor(self, ancestor_rev: Commit, rev: Commit) -> bool:
        """Check if a commit is an ancestor of another

        :param ancestor_rev: Rev which should be an ancestor
        :param rev: Rev to test against ancestor_rev
        :return: ``True``, ancestor_rev is an ancestor to rev.
        """
        ...
    def is_valid_object(
        self, sha: str, object_type: Union[str, None] = ...
    ) -> bool: ...

    daemon_export = ...
    alternates = ...
    def is_dirty(
        self,
        index: bool = ...,
        working_tree: bool = ...,
        untracked_files: bool = ...,
        submodules: bool = ...,
        path: Optional[PathLike] = ...,
    ) -> bool:
        """
        :return:
            ``True``, the repository is considered dirty. By default it will react
            like a git-status without untracked files, hence it is dirty if the
            index or the working copy have changes."""
        ...
    @property
    def untracked_files(self) -> List[str]:
        """
        :return:
            list(str,...)

            Files currently untracked as they have not been staged yet. Paths
            are relative to the current working directory of the git command.

        :note:
            ignored files will not appear here, i.e. files mentioned in .gitignore
        :note:
            This property is expensive, as no cache is involved. To process the result, please
            consider caching it yourself."""
        ...
    def ignored(self, *paths: PathLike) -> List[str]:
        """Checks if paths are ignored via .gitignore
        Doing so using the "git check-ignore" method.

        :param paths: List of paths to check whether they are ignored or not
        :return: subset of those paths which are ignored
        """
        ...
    @property
    def active_branch(self) -> Head:
        """The name of the currently active branch.

        :raises	TypeError: If HEAD is detached
        :return: Head to the active branch"""
        ...
    def blame_incremental(
        self, rev: str | HEAD, file: str, **kwargs: Any
    ) -> Iterator[BlameEntry]:
        """Iterator for blame information for the given file at the given revision.

        Unlike .blame(), this does not return the actual file's contents, only
        a stream of BlameEntry tuples.

        :param rev: revision specifier, see git-rev-parse for viable options.
        :return: lazy iterator of BlameEntry tuples, where the commit
                 indicates the commit to blame for the line, and range
                 indicates a span of line numbers in the resulting file.

        If you combine all line number ranges outputted by this command, you
        should get a continuous range spanning all line numbers in the file.
        """
        ...
    def blame(
        self,
        rev: Union[str, HEAD],
        file: str,
        incremental: bool = ...,
        rev_opts: Optional[List[str]] = ...,
        **kwargs: Any
    ) -> List[List[Commit | List[str | bytes] | None]] | Iterator[BlameEntry] | None:
        """The blame information for the given file at the given revision.

        :param rev: revision specifier, see git-rev-parse for viable options.
        :return:
            list: [git.Commit, list: [<line>]]
            A list of lists associating a Commit object with a list of lines that
            changed within the given commit. The Commit objects will be given in order
            of appearance."""

        class InfoTD(TypedDict, total=False): ...

    @classmethod
    def init(
        cls,
        path: Union[PathLike, None] = ...,
        mkdir: bool = ...,
        odbt: Type[GitCmdObjectDB] = ...,
        expand_vars: bool = ...,
        **kwargs: Any
    ) -> Repo:
        """Initialize a git repository at the given path if specified

        :param path:
            is the full path to the repo (traditionally ends with /<name>.git)
            or None in which case the repository will be created in the current
            working directory

        :param mkdir:
            if specified will create the repository directory if it doesn't
            already exists. Creates the directory with a mode=0755.
            Only effective if a path is explicitly given

        :param odbt:
            Object DataBase type - a type which is constructed by providing
            the directory containing the database objects, i.e. .git/objects.
            It will be used to access all object data

        :param expand_vars:
            if specified, environment variables will not be escaped. This
            can lead to information disclosure, allowing attackers to
            access the contents of environment variables

        :param kwargs:
            keyword arguments serving as additional options to the git-init command

        :return: ``git.Repo`` (the newly created repo)"""
        ...
    def clone(
        self,
        path: PathLike,
        progress: Optional[Callable] = ...,
        multi_options: Optional[List[str]] = ...,
        allow_unsafe_protocols: bool = ...,
        allow_unsafe_options: bool = ...,
        **kwargs: Any
    ) -> Repo:
        """Create a clone from this repository.

        :param path: is the full path of the new repo (traditionally ends with ./<name>.git).
        :param progress: See 'git.remote.Remote.push'.
        :param multi_options: A list of Clone options that can be provided multiple times.  One
            option per list item which is passed exactly as specified to clone.
            For example ['--config core.filemode=false', '--config core.ignorecase',
            '--recurse-submodule=repo1_path', '--recurse-submodule=repo2_path']
        :param allow_unsafe_protocols: Allow unsafe protocols to be used, like ext
        :param allow_unsafe_options: Allow unsafe options to be used, like --upload-pack
        :param kwargs:
            * odbt = ObjectDatabase Type, allowing to determine the object database
              implementation used by the returned Repo instance
            * All remaining keyword arguments are given to the git-clone command

        :return: ``git.Repo`` (the newly cloned repo)"""
        ...
    @classmethod
    def clone_from(
        cls,
        url: PathLike,
        to_path: PathLike,
        progress: Optional[Callable] = ...,
        env: Optional[Mapping[str, str]] = ...,
        multi_options: Optional[List[str]] = ...,
        allow_unsafe_protocols: bool = ...,
        allow_unsafe_options: bool = ...,
        **kwargs: Any
    ) -> Repo:
        """Create a clone from the given URL

        :param url: valid git url, see http://www.kernel.org/pub/software/scm/git/docs/git-clone.html#URLS
        :param to_path: Path to which the repository should be cloned to
        :param progress: See 'git.remote.Remote.push'.
        :param env: Optional dictionary containing the desired environment variables.
            Note: Provided variables will be used to update the execution
            environment for `git`. If some variable is not specified in `env`
            and is defined in `os.environ`, value from `os.environ` will be used.
            If you want to unset some variable, consider providing empty string
            as its value.
        :param multi_options: See ``clone`` method
        :param allow_unsafe_protocols: Allow unsafe protocols to be used, like ext
        :param allow_unsafe_options: Allow unsafe options to be used, like --upload-pack
        :param kwargs: see the ``clone`` method
        :return: Repo instance pointing to the cloned directory"""
        ...
    def archive(
        self,
        ostream: Union[TextIO, BinaryIO],
        treeish: Optional[str] = ...,
        prefix: Optional[str] = ...,
        **kwargs: Any
    ) -> Repo:
        """Archive the tree at the given revision.

        :param ostream: file compatible stream object to which the archive will be written as bytes
        :param treeish: is the treeish name/id, defaults to active branch
        :param prefix: is the optional prefix to prepend to each filename in the archive
        :param kwargs: Additional arguments passed to git-archive

            * Use the 'format' argument to define the kind of format. Use
              specialized ostreams to write any format supported by python.
            * You may specify the special **path** keyword, which may either be a repository-relative
              path to a directory or file to place into the archive, or a list or tuple of multiple paths.

        :raise GitCommandError: in case something went wrong
        :return: self"""
        ...
    def has_separate_working_tree(self) -> bool:
        """
        :return: True if our git_dir is not at the root of our working_tree_dir, but a .git file with a
            platform agnositic symbolic link. Our git_dir will be wherever the .git file points to
        :note: bare repositories will always return False here
        """
        ...
    rev_parse = ...
    def __repr__(self) -> str: ...
    def currently_rebasing_on(self) -> Commit | None:
        """
        :return: The commit which is currently being replayed while rebasing.

        None if we are not currently rebasing.
        """
        ...
